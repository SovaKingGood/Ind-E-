/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --board "/boards/LAUNCHXL_F28379D" --device "F2837xD" --part "F2837xD_337ZWT" --package "F2837xD_337ZWT" --context "CPU1" --product "C2000WARE@5.04.00.00"
 * @v2CliArgs --board "/boards/LAUNCHXL_F28379D" --device "TMS320F28379D" --package "337ZWT" --context "CPU1" --product "C2000WARE@5.04.00.00"
 * @versions {"tool":"1.22.0+3893"}
 */

/**
 * Import the modules used in this configuration.
 */
const adc              = scripting.addModule("/driverlib/adc.js", {}, false);
const adc1             = adc.addInstance();
const adc2             = adc.addInstance();
const adc3             = adc.addInstance();
const ecap             = scripting.addModule("/driverlib/ecap.js", {}, false);
const ecap1            = ecap.addInstance();
const epwm             = scripting.addModule("/driverlib/epwm.js");
const epwm1            = epwm.addInstance();
const epwm2            = epwm.addInstance();
const epwm3            = epwm.addInstance();
const epwm4            = epwm.addInstance();
const epwm5            = epwm.addInstance();
const eqep             = scripting.addModule("/driverlib/eqep.js", {}, false);
const eqep1            = eqep.addInstance();
const gpio             = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1            = gpio.addInstance();
const gpio2            = gpio.addInstance();
const gpio3            = gpio.addInstance();
const gpio4            = gpio.addInstance();
const gpio5            = gpio.addInstance();
const gpio6            = gpio.addInstance();
const inputxbar_input  = scripting.addModule("/driverlib/inputxbar_input.js", {}, false);
const inputxbar_input1 = inputxbar_input.addInstance();
const inputxbar_input2 = inputxbar_input.addInstance();
const sync             = scripting.addModule("/driverlib/sync.js");

/**
 * Write custom configuration values to the imported modules.
 */
adc1.$name               = "myADC0";
adc1.soc0SampleWindow    = 20;
adc1.interruptPulseMode  = "ADC_PULSE_END_OF_CONV";
adc1.enableInterrupt1    = true;
adc1.interrupt1SOCSource = "ADC_SOC_NUMBER1";
adc1.adcClockPrescaler   = "ADC_CLK_DIV_4_0";
adc1.soc1SampleWindow    = 20;
adc1.enableInterrupt4    = true;
adc1.enableInterrupt2    = true;
adc1.enabledInts         = ["ADC_INT_NUMBER2"];
adc1.interrupt2SOCSource = "ADC_SOC_NUMBER1";
adc1.soc0Trigger         = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc1Trigger         = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc2SampleWindow    = 20;
adc1.soc2Channel         = "ADC_CH_ADCIN2";
adc1.soc2Trigger         = "ADC_TRIGGER_EPWM1_SOCA";
adc1.enabledSOCs         = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3"];
adc1.soc2Name            = "A_HIGH";
adc1.soc3Name            = "A_LOW";
adc1.soc3Channel         = "ADC_CH_ADCIN3";
adc1.soc3Trigger         = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc3SampleWindow    = 20;
adc1.soc1Channel         = "ADC_CH_ADCIN1";

adc2.$name             = "myADCB";
adc2.adcBase           = "ADCB_BASE";
adc2.adcClockPrescaler = "ADC_CLK_DIV_4_0";
adc2.enabledSOCs       = ["ADC_SOC_NUMBER0"];
adc2.soc0SampleWindow  = 20;

adc3.$name             = "myADCC";
adc3.adcClockPrescaler = "ADC_CLK_DIV_4_0";
adc3.soc0SampleWindow  = 20;
adc3.enabledSOCs       = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER2"];
adc3.soc2Name          = "B_Low";
adc3.soc2Channel       = "ADC_CH_ADCIN2";
adc3.soc2SampleWindow  = 20;
adc3.soc2Trigger       = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc0Trigger       = "ADC_TRIGGER_EPWM1_SOCA";
adc3.adcBase           = "ADCC_BASE";

ecap1.eventTwoPolarity        = "ECAP_EVNT_FALLING_EDGE";
ecap1.eventFourPolarity       = "ECAP_EVNT_FALLING_EDGE";
ecap1.enableInterrupt         = true;
ecap1.registerInterrupts      = true;
ecap1.$name                   = "esp32pwm";
ecap1.ecapBase                = "ECAP2_BASE";
ecap1.syncOutMode             = "ECAP_SYNC_OUT_DISABLED";
ecap1.interruptSourceCapture  = ["ECAP_ISR_SOURCE_CAPTURE_EVENT_4"];
ecap1.eventStop               = "ECAP_EVENT_4";
ecap1.ecapInt.enableInterrupt = true;

epwm.generateInitFunctions = true;

epwm1.$name                                             = "PhaseA";
epwm1.epwmActionQualifier_t2Source                      = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_2";
epwm1.epwmDeadband_enableRED                            = true;
epwm1.epwmDeadband_enableFED                            = true;
epwm1.epwmEventTrigger_enableInterrupt                  = true;
epwm1.epwmEventTrigger_registerInterrupts               = true;
epwm1.epwmEventTrigger_interruptEventCount              = "1";
epwm1.epwmDeadband_polarityFED                          = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm1.epwmEventTrigger_interruptSource                  = "EPWM_INT_TBCTR_U_CMPC";
epwm1.epwmCounterCompare_cmpC                           = 5;
epwm1.epwmCounterCompare_cmpA                           = 5;
epwm1.epwmCounterCompare_cmpB                           = 5;
epwm1.epwmDeadband_deadbandCounterClockRate             = "EPWM_DB_COUNTER_CLOCK_HALF_CYCLE";
epwm1.epwmDeadband_redShadowMode                        = true;
epwm1.epwmDeadband_fedShadowMode                        = true;
epwm1.epwmDeadband_delayRED                             = 50;
epwm1.epwmDeadband_delayFED                             = 50;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEnable         = true;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerSource         = "EPWM_SOC_TBCTR_U_CMPD";
epwm1.epwmCounterCompare_cmpD                           = 10;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar = "10";
epwm1.epwmTimebase_periodLoadMode                       = "EPWM_PERIOD_DIRECT_LOAD";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode   = true;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowMode   = true;
epwm1.hrpwm_syncSource                                  = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm1.epwmTimebase_periodGld                            = true;
epwm1.epwmCounterCompare_cmpDGld                        = true;
epwm1.$hardware                                         = system.deviceData.board.components.BP_SITE_1.subComponents.PWM_LOC1;
epwm1.epwmTimebase_syncOutPulseMode                     = "EPWM_SYNC_OUT_PULSE_ON_COUNTER_ZERO";
epwm1.epwmCounterCompare_shadowLoadModeCMPA             = "EPWM_COMP_LOAD_ON_CNTR_PERIOD";
epwm1.epwmCounterCompare_shadowLoadModeCMPB             = "EPWM_COMP_LOAD_ON_CNTR_PERIOD";
epwm1.epwmTimebase_hsClockDiv                           = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmTimebase_counterMode                          = "EPWM_COUNTER_MODE_UP";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowEvent  = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowEvent  = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm1.epwmTimebase_period                               = 4000;
epwm1.epwmInt.enableInterrupt                           = true;
epwm1.epwm.$assign                                      = "EPWM1";
epwm1.epwm.epwm_aPin.$assign                            = "boosterpack1.40";
epwm1.epwm.epwm_bPin.$assign                            = "boosterpack1.39";

epwm2.epwmActionQualifier_t2Source                     = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_2";
epwm2.epwmCounterCompare_cmpB                          = 1;
epwm2.epwmDeadband_enableRED                           = true;
epwm2.epwmDeadband_enableFED                           = true;
epwm2.epwmDeadband_polarityFED                         = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm2.$name                                            = "PhaseB";
epwm2.$hardware                                        = system.deviceData.board.components.BP_SITE_1.subComponents.PWM_LOC2;
epwm2.epwmCounterCompare_cmpA                          = 2;
epwm2.epwmDeadband_deadbandCounterClockRate            = "EPWM_DB_COUNTER_CLOCK_HALF_CYCLE";
epwm2.epwmDeadband_delayRED                            = 50;
epwm2.epwmDeadband_delayFED                            = 50;
epwm2.epwmDeadband_redShadowMode                       = true;
epwm2.epwmDeadband_fedShadowMode                       = true;
epwm2.epwmTimebase_periodLoadMode                      = "EPWM_PERIOD_DIRECT_LOAD";
epwm2.epwmCounterCompare_enableShadowLoadModeCMPD      = false;
epwm2.epwmCounterCompare_enableShadowLoadModeCMPC      = false;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowMode  = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode  = true;
epwm2.hrpwm_syncSource                                 = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm2.epwmTimebase_periodGld                           = true;
epwm2.epwmTimebase_periodLink                          = "EPWM_LINK_WITH_EPWM_1";
epwm2.epwmTimebase_phaseEnable                         = true;
epwm2.epwmCounterCompare_cmpALink                      = "EPWM_LINK_WITH_EPWM_1";
epwm2.epwmCounterCompare_cmpBLink                      = "EPWM_LINK_WITH_EPWM_1";
epwm2.epwmCounterCompare_enableShadowLoadModeCMPB      = false;
epwm2.epwmCounterCompare_enableShadowLoadModeCMPA      = false;
epwm2.epwmTimebase_syncOutPulseMode                    = "EPWM_SYNC_OUT_PULSE_ON_EPWMxSYNCIN";
epwm2.epwmTimebase_hsClockDiv                          = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmTimebase_counterMode                         = "EPWM_COUNTER_MODE_UP";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowEvent = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowEvent = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm2.epwmTimebase_phaseShift                          = 2;
epwm2.epwmTimebase_period                              = 4000;
epwm2.epwm.$assign                                     = "EPWM2";
epwm2.epwm.epwm_aPin.$assign                           = "boosterpack1.38";
epwm2.epwm.epwm_bPin.$assign                           = "boosterpack1.37";

epwm3.epwmActionQualifier_t2Source                     = "EPWM_AQ_TRIGGER_EVENT_TRIG_DCA_2";
epwm3.epwmDeadband_enableRED                           = true;
epwm3.epwmDeadband_enableFED                           = true;
epwm3.epwmDeadband_polarityFED                         = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm3.$name                                            = "PhaseC";
epwm3.$hardware                                        = system.deviceData.board.components.BP_SITE_1.subComponents.PWM_LOC3;
epwm3.epwmDeadband_deadbandCounterClockRate            = "EPWM_DB_COUNTER_CLOCK_HALF_CYCLE";
epwm3.epwmDeadband_delayRED                            = 50;
epwm3.epwmDeadband_delayFED                            = 50;
epwm3.epwmCounterCompare_cmpA                          = 5;
epwm3.epwmCounterCompare_cmpB                          = 5;
epwm3.epwmTimebase_periodGld                           = true;
epwm3.epwmTimebase_periodLoadMode                      = "EPWM_PERIOD_DIRECT_LOAD";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowMode  = true;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode  = true;
epwm3.epwmCounterCompare_enableShadowLoadModeCMPD      = false;
epwm3.hrpwm_syncSource                                 = "HRPWM_PWMSYNC_SOURCE_ZERO";
epwm3.epwmCounterCompare_shadowLoadModeCMPC            = "EPWM_COMP_LOAD_ON_CNTR_PERIOD";
epwm3.epwmTimebase_periodLink                          = "EPWM_LINK_WITH_EPWM_1";
epwm3.epwmTimebase_phaseEnable                         = true;
epwm3.epwmCounterCompare_cmpALink                      = "EPWM_LINK_WITH_EPWM_1";
epwm3.epwmCounterCompare_cmpBLink                      = "EPWM_LINK_WITH_EPWM_1";
epwm3.epwmCounterCompare_enableShadowLoadModeCMPB      = false;
epwm3.epwmCounterCompare_enableShadowLoadModeCMPA      = false;
epwm3.epwmTimebase_syncOutPulseMode                    = "EPWM_SYNC_OUT_PULSE_ON_EPWMxSYNCIN";
epwm3.epwmTimebase_hsClockDiv                          = "EPWM_HSCLOCK_DIVIDER_1";
epwm3.epwmTimebase_counterMode                         = "EPWM_COUNTER_MODE_UP";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowEvent = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_B_shadowEvent = "EPWM_AQ_LOAD_ON_CNTR_PERIOD";
epwm3.epwmTimebase_phaseShift                          = 2;
epwm3.epwmDeadband_fedShadowMode                       = true;
epwm3.epwmDeadband_redShadowMode                       = true;
epwm3.epwmTimebase_period                              = 4000;
epwm3.epwm.$assign                                     = "EPWM3";
epwm3.epwm.epwm_aPin.$assign                           = "boosterpack1.36";
epwm3.epwm.epwm_bPin.$assign                           = "boosterpack1.35";

epwm4.$name                                       = "rpmInterrupt";
epwm4.epwmTimebase_syncOutPulseMode               = "EPWM_SYNC_OUT_PULSE_DISABLED";
epwm4.epwmTimebase_counterMode                    = "EPWM_COUNTER_MODE_UP";
epwm4.epwmEventTrigger_enableInterrupt            = true;
epwm4.epwmEventTrigger_registerInterrupts         = true;
epwm4.epwmEventTrigger_interruptEventCount        = "1";
epwm4.epwmTimebase_period                         = 60000;
epwm4.$hardware                                   = system.deviceData.board.components.BP_SITE_2.subComponents.PWM_LOC1;
epwm4.epwmCounterCompare_enableShadowLoadModeCMPA = false;
epwm4.epwmCounterCompare_cmpA                     = 30000;
epwm4.epwmEventTrigger_interruptSource            = "EPWM_INT_TBCTR_U_CMPA";
epwm4.epwmTimebase_clockDiv                       = "EPWM_CLOCK_DIVIDER_128";
epwm4.epwmInt.enableInterrupt                     = true;

epwm5.$name                                                     = "Blue_Led";
epwm5.$hardware                                                 = system.deviceData.board.components.BP_SITE_2.subComponents.PWM_LOC3;
epwm5.epwmTimebase_period                                       = 30000;
epwm5.epwmTimebase_counterMode                                  = "EPWM_COUNTER_MODE_UP";
epwm5.epwmTimebase_emulationMode                                = "EPWM_EMULATION_FREE_RUN";
epwm5.epwmCounterCompare_cmpA                                   = 5000;
epwm5.epwmActionQualifier_EPWM_AQ_OUTPUT_B_onetimeSwForceAction = "EPWM_AQ_OUTPUT_TOGGLE";
epwm5.epwmTimebase_hsClockDiv                                   = "EPWM_HSCLOCK_DIVIDER_12";
epwm5.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA  = "EPWM_AQ_OUTPUT_HIGH";
epwm5.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_ZERO     = "EPWM_AQ_OUTPUT_LOW";

eqep1.$name                = "RPM";
eqep1.positionCounterMode  = "EQEP_POSITION_RESET_MAX_POS";
eqep1.positionCounterMax   = 2000;
eqep1.enableModule         = true;
eqep1.initialPosition      = 1000;
eqep1.positionStrobeEvents = "EQEP_INIT_EDGE_DIR_STROBE";
eqep1.setPosition          = 1000;
eqep1.interruptSources     = ["EQEP_INT_GLOBAL"];
eqep1.useInterrupts        = false;
eqep1.$hardware            = system.deviceData.board.components.EQEP2_HEADER;

gpio1.$name           = "Brake";
gpio1.gpioPin.$assign = "boosterpack1.2";

gpio2.$name           = "Reverse";
gpio2.gpioPin.$assign = "boosterpack1.11";

gpio3.$name           = "HALL_A";
gpio3.gpioPin.$assign = "boosterpack1.5";

gpio4.$name           = "HALL_B";
gpio4.gpioPin.$assign = "boosterpack1.8";

gpio5.$name           = "HALL_C";
gpio5.gpioPin.$assign = "boosterpack2.46";

gpio6.$name    = "ESP32PWM";
gpio6.qualMode = "GPIO_QUAL_ASYNC";

inputxbar_input1.$name = "myINPUTXBARINPUT0";

inputxbar_input2.inputxbarInput = "XBAR_INPUT8";
inputxbar_input2.$name          = "ESP32XBAR";
inputxbar_input2.inputxbarGpio  = "GPIO122";

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
epwm4.epwm.$suggestSolution           = "EPWM4";
epwm4.epwm.epwm_aPin.$suggestSolution = "boosterpack2.80";
epwm4.epwm.epwm_bPin.$suggestSolution = "boosterpack2.79";
epwm5.epwm.$suggestSolution           = "EPWM6";
epwm5.epwm.epwm_aPin.$suggestSolution = "boosterpack2.76";
epwm5.epwm.epwm_bPin.$suggestSolution = "boosterpack2.75";
eqep1.eqep.$suggestSolution           = "EQEP2";
eqep1.eqep.eqepaPin.$suggestSolution  = "qepB.1";
eqep1.eqep.eqepbPin.$suggestSolution  = "qepB.2";
eqep1.eqep.eqepiPin.$suggestSolution  = "qepB.3";
gpio6.gpioPin.$suggestSolution        = "boosterpack1.17";
